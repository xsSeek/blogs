## this指向的四种规则

> 面向对象语言中 this 表示当前对象的一个引用。
> 但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。

### 01.默认绑定
a.全局作用域中this指向window

```js
console.log({} === {}) // false
console.log(this === window) // true 全局作用域
```

b.函数的独立调用 非严格模式下this 指向 window; 严格模式指向 undefined

```js
// 函数的独立调用
function x() {
  console.log(this)
}
x() // 与window.x()效果一致 函数的独立调用
```

### 02.隐式绑定规则
a.在对象中的方法中, this 表示该方法所属的对象(谁调用就指向谁)

```js
const obj = {
  a: 1,
  test() {
    console.log(this) // obj
    function x() {
      console.log(this) // window 这里是函数的独立调用
    }
    x();
    (function () {
      console.log(this) // window 函数声明后马上调用 函数的独立调用
    })()
  }
}
obj.test()
```

b.闭包（closure）中this 执向window
> 当函数执行的时候 导致新函数被定义, 并抛出

```js
const obj = {
  a: 1,
  test() {
    console.log(this) // obj
    function x() {
      console.log(this) // window 这里是函数的独立调用
    }
    return x
  }
}
obj.test()() // x() 也是函数的独立调用
```

c.变量赋值的情况

```js
const a  = 0
function foo() {
  console.log(this)
}
const obj = {
  a: 2,
  foo: foo,
}
// 隐式丢失≠
const bar = obj.foo
bar() // 0 函数的独立调用
```

d.函数参数赋值的情况

```js
const a = 0
function foo() {
  console.log(this)
}
function bar(fn) {
  fn()
}
const obj = {
  a: 2,
  foo: foo,
}

bar(obj.foo) // window
```

e: 回掉函数函数中的this

```js
const arr = [1, 2]
arr.forEach(function () {
  console.log(this) // widnow
})
arr.sort(function (a, b) {
  console.log(this) // window
  return a - b
})

setInterval(function () {
  console.log(this) // window
})
```

### 03. 显式绑定
> call apply bind

```js
const a = 0
function foo(a, b, c, d, e) {
  console.log(a, b, c, d, e)
  console.log(this)
}
const obj = {
  a: 2,
  foo
}
const bar = obj.foo

obj.foo(1, 2, 3, 4, 5)
bar.call(obj, 1, 2, 3, 4, 5)
bar.call(100, 1, 2, 3, 4, 5) // Number的实例对象 { 100 }
bar.call(true, 1, 2, 3, 4, 5) // Boolean的实例对象 { true }
bar.call('a', 1, 2, 3, 4, 5) // String的实例对象 { 'a' }
bar.call(null, 1, 2, 3, 4, 5) // 绑定失败 默认指向window
bar.call(undefined, 1, 2, 3, 4, 5) // 绑定失败 默认指向window
bar.apply(obj, [1, 2, 3, 4, 5])
bar.bind(obj)(1, 2, 3, 4, 5)
```

### 04.new 关键字绑定

```js
function Person() {
  this.name = 'Tom'
  this.age = 33
  console.log(this, 'this') // 指向生产的新对象
}
const person = new Person()
console.log(person) // 新对象的引用

const obj2 = {
  a: 1
}
;(function () {
  console.log(this) // obj2
}).call(obj2)
```

### 05. this 绑定的优先级 new > 显示绑定 > 隐式绑定 > 默认绑定

```js
function test() {
  console.log(this.a)
}

const obj1 = {
  a: 2,
  test: test,
}

const obj2 = {
  a: 3,
  test,
}

obj1.test() // 隐式绑定
obj2.test() // 隐式绑定

obj1.test.call(obj2) // 显示绑定优先级大于隐式绑定 3
obj2.test.call(obj1) // 显示绑定优先级大于隐式绑定 2
```

```js
function foo(b) {
  this.a = b
}
const obj1 = {}
const bar = foo.bind(obj1)
bar(2) //  执行到这里的时候 bar = foo(b) { obj1.a = 2 }
console.log(obj1.a) // 2
const baz = new bar(3) // new绑定优先级高于bind this指向baz
console.log(obj1.a) // 2

console.log(baz.a) // 3
```

- 在事件中 this指向触发的对象

```html
<button onclick="this.style.display='none'">点我后我就消失了</button>
```

> 默认绑定 函数独立调用改变箭头函数中 this 无效

```js
const a = 0
function foo() {
  console.log(this) // obj
  const test = () => {
    console.log(this)  // obj
  }
  return test
}
const obj = {
  a: 1,
  foo
}
obj.foo()() // 默认绑定规则（独立调用）对箭头函数无效
```

> 隐式绑定

```js
const a = 0
function foo() {
  console.log(this)
}
const foo2 = () => {
  console.log(this)
}
const obj = {
  a: 1,
  foo,
  foo2,
}
obj.foo() // obj
obj.foo2() // window 隐式绑定规则无效
```

> 显示绑定改变箭头函数中this 无效

```js
const a = 0
function foo() {
  console.log(this) // obj
  const test = () => {
    console.log(this)  // obj
  }
  return test
}
const obj1 = {
  a: 1,
  foo
}
const obj2 = {
  a: 2,
  foo
}
const bar = foo.call(obj2) // 显示绑定规则绑定规则无效
bar()
```

> 箭头函数中的this 箭头函数不存在this 指的是父级作用域中的this

```js
const a = 0
function foo() {
  console.log(this) // obj
  const test = () => {
    console.log(this) // obj 父级作用域中的this 有父级作用域的this
  }
  test()
}
const obj = {
  a: 1,
  foo
}
obj.foo()
```

### 面试题

```js
var name = 'window'

var person1 = {
  name: 'person1',
  foo1: function () {
    console.log(this.name)
  },
  foo2: () => console.log(this.name),
  foo3: function () {
    return function () {
      console.log(this.name)
    }
  },
  foo4: function () {
    return () => {
      console.log(this.name)
    }
  }
}

var person2 = { name: 'person2' }

person1.foo1() // person1
person1.foo1.call(person2) // pserson2

person1.foo2() // window
person1.foo2.call(person2) // window

person1.foo3()() // window
person1.foo3.call(person2)() // window
person1.foo3().call(person2) // person2

person1.foo4()() // person1
person1.foo4.call(person2)() // pserson2
person1.foo4().call(person2) // pserson1
```

> 做一道阿里关于this的面试题

```js
var name = 222;
var a = {
  name: 111,
  say: function () {
    console.log(this.name);
  },
};

var fun = a.say;
fun() //222   fun.call(window) 函数独立调用
a.say() //111  a.say.call(a) 隐式绑定

var b = {
  name: 333,
  say: function (fun) {
    fun()
  },
}

b.say(a.say) //222 函数独立调用
b.say = a.say
b.say() //333 隐式绑定
```
