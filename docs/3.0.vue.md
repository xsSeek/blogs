# vue 面试题

## 什么是 MVVM

<img class='zoom-imgs' src="https://github.com/scott8013/readme-images/blob/main/WX20210324-203950@2x.png?raw=true" alt="mvvm">

:::tip
MVVM是Model-View-ViewModel的缩写。前端开发的架构模式

M：模型，对应的就是data的数据

V：视图，用户界面，DOM

VM：视图模型：Vue的实例对象，连接View和Model的桥梁
MVVM的核心是提供对View和ViewModel的双向数据绑定，当数据改变的时候，ViewModel能监听到数据的变化，自动更新视图，
当用户操作视图的时候，ViewModel也可以监听到视图的变化，然后通知数据进行改动，这就实现了双向数据绑定
ViewModel通过双向绑定把View和Model连接起来，他们之间的同步是自动的，不需要认为干涉，所以我们只需要关注业务逻辑即可，不需要操作DOM，同时也不需要关注数据的状态问题，因为她是由MVVM统一管理
:::

## v-for中的key值的作用是什么？

> key属性是DOM元素的唯一标识
> 作用：

- 1.提高虚拟DOM的更新效率
- 2.若不设置key，可能会触发一些bug
- 3.为了触发过度效果

## 说一下你对vue生命周期的理解。

> 组件从创建到销毁的过程就是它的生命周期

1.创建
:::tip
a.beforeCreat
时机：组件实例刚创建，但数据观测 (data) 和事件配置 (methods) 未初始化。
用途：常用于插件初始化（如 Vuex 或路由的初始化）

b.created
时机：props, 数据观测 (data)、计算属性 (computed)、方法 (methods) 已初始化，但 DOM 未生成。
用途：发起异步请求（如 API 调用）、初始化非 DOM 相关数据。
:::
2.挂载

:::tip
a.beforeMount
时机：模板编译完成，但尚未将组件挂载到 DOM。
用途：极少使用，一般用于服务端渲染
b.Mounted
时机：组件已挂载到 DOM 上，可以访问 this.$el
用途：操作 DOM（如绑定第三方库）、发起依赖 DOM 的请求
:::

3.更新
:::tip
beforeUpdate
时机：数据变化后，DOM 重新渲染前。

用途：获取更新前的 DOM 状态。
updated
时机：DOM 已更新完成。

用途：执行依赖更新后 DOM 的操作，需避免在此修改数据（可能导致无限循环）。
:::
4.销毁
:::tip
beforeDestroy
时机：组件销毁前，实例仍可用。

用途：清除定时器、取消事件监听、销毁第三方库实例。
destroyed
时机：组件已销毁，所有子实例和事件监听被移除。

用途：执行最后的清理操作。
:::
5.使用了keep-alive时多出两个周期：
activited
组件激活时
deactivited

## 在created和mounted去请求数据，有什么区别？

### 1. **触发时机**

- **`created`**：  
  在组件实例创建完成后调用，此时数据观测 (`data`)、计算属性、方法等已初始化，**但 DOM 还未生成**（`this.$el` 不可用）。
- **`mounted`**：  
  在组件首次渲染并挂载到 DOM 后调用，此时可以访问 DOM 元素（`this.$el` 可用）。

---

### 2. **数据请求的适用场景**

#### **在 `created` 中请求数据**

- **优势**：  
  可以更早发起异步请求，减少用户等待时间（尤其当数据获取和模板渲染不依赖 DOM 时）。
- **适用场景**：
    - 数据不依赖 DOM，仅用于填充模板。
    - 需要服务端渲染（SSR）时，`created` 会在服务端执行，而 `mounted` 不会。
    - 父组件需在子组件挂载前传递数据。

#### **在 `mounted` 中请求数据**

- **优势**：  
  可以操作 DOM，例如初始化第三方库（如地图、图表）。
- **适用场景**：
    - 数据返回后需要直接操作 DOM。
    - 需要确保子组件已挂载，再基于 DOM 布局请求数据（如获取元素尺寸）。

---

### 3. **用户体验差异**

- **`created` 请求**：  
  数据返回后触发重新渲染，用户可能看到内容从“初始状态”到“数据填充”的变化。
- **`mounted` 请求**：  
  用户可能先看到初始渲染内容（如骨架屏），稍后看到数据更新。

---

### 4. **服务端渲染 (SSR) 注意事项**

- **`created`**：  
  在服务端和客户端均会执行，需确保请求代码兼容 Node.js 环境（如使用 `axios`）。
- **`mounted`**：  
  仅在客户端执行，无法用于服务端预取数据。

---

### 5. **代码示例**

```javascript
// 在 created 中请求（不依赖 DOM）
export default {
    created() {
        this.fetchData(); // 更早发起请求
    },
    methods: {
        async fetchData() {
            const data = await api.get('/data');
            this.items = data;
        },
    },
};

// 在 mounted 中请求（依赖 DOM）
export default {
    mounted() {
        this.initChart(); // 需要 DOM 存在
        this.fetchData();
    },
    methods: {
        initChart() {
            this.chart = new Chart(this.$refs.canvas, {...});
        },
        async fetchData() {
            const data = await api.get('/chart-data');
            this.chart.update(data);
        },
    },
};
```

---

### **总结**

- 优先使用 **`created`**：  
  数据不依赖 DOM，需更快发起请求或支持 SSR。
- 使用 **`mounted`**：  
  需要操作 DOM 或等待子组件挂载。
- **关键考量**：是否需要访问 DOM、服务端渲染兼容性、用户体验优化（如避免内容闪烁）。

## vue中的修饰符有哪些？

### 1.事件修饰符

.stop 组织冒泡
.prevent 组织默认行为
.capture 即是给元素添加一个监听器，当元素发生冒泡时，先触发带有该修饰符的元素。若有多个该修饰符，则由外而内触发。
就是谁有该事件修饰符，就先触发谁
.self 只有在event.target是当前元素时触发
.once 事件只会触发一次
.passive 立即触发默认行为
.native 把当前元素作为原生标签看待

### 2.按键修饰符

.enter
.tab
.delete
.esc
.space
.up
.down
.left
.right
.keyup 键盘抬起
.keydown 键盘按下

### 3.系统修饰符

.ctrl
.shift
.alt
.meta

### 4.鼠标修饰符

.left 鼠标左键
.right 鼠标右键
.middle 鼠标中键

### 5.表单修饰符

.lazy 等输入完之后再显示
.trim 删除内容前后的空格
.number 输入是数字或转为数字

### elementui是怎么做表单验证的

1.在表单中加rules属性，然后再data里写校验规则
2.内部添加规则
3.自定义函数校验

### vue如何进行组件通信

- 01.父到子
  :::
    - 01.props
    - 02.父组建默认暴露(defineExpose)方法，父通过模板引用获取子组建实例, 调用子组建暴露方法，并传参
  :::
- 02.子到父
  :::tip
    - 01.父自定义事件，子emit触发自定义事件，并传参给父组建
    - 02.把函数作为属性传给子组建，在子调用函数并传参数
    - 03.作用域插槽 子：`<slot :obj="obj" :age="age"></slot>` 父： `<template #default="{obj, age}"></template>`
    - 03.1作用域插槽 子：`<slot name="slot1" :obj="obj" :age="age"></slot>` 父：
      `<template v-slot:slot1="{obj, age}"></template>`
- :::
- 03.兄弟
  mitt
- 04.祖孙
  provide, inject

useAttrs($attrs)

v-modal + defineModal
pinia

## vue 和 react 区别

### 相同点

- 01.都支持组建化开发 和 Virtual DOM
- 02.都支持props进行父子组建间数据通讯
- 03.都支持数据驱动试图 不直接操作真实DOM 更新状态数据界面会自动更新.
- 04.都支持服务端渲染
- 05.都有支持native的方案, React使用React Native, Vue使用Week

### 不同点

- 01.数据绑定: vue实现了数据的双向绑定, react数据流动是单向的
- 02.组建写法不一样, React推荐语法JSX, 也就是HTML和CSS全都写进JavaScript里, 即 All In js. Vue推荐的做法是(webpack +
  vue-loader)的单文件组建的格式, 即 html css js 写在同一个文件.
- 03.state对象在react应用中不可改变, 需用使用setState方法更新状态, 在vue中, state对象不是必须的, 数据由data熟悉在vue对象中管理
- 04.virtual Dom不一样, vue会跟踪每一个组建的依赖关系, 不需要重新渲染组建树. 而对于React而言, 每个应用的状态被改变时,
  全部组建都会重新渲染. 所以react中会需要shouldComponentUpdate这个声明周期函数方法来进行控制.
- 05.React严格上只针对MVC的view层. Vue则是MVVM模式

## webpack 中 loader 和 plugin 的区别是什么

loader：loader 是一个转换器，将 A 文件进行编译成 B 文件，属于单纯的文件转换过程

plugin：plugin 是一个扩展器，它丰富了 webpack 本身，针对是 loader 结束后，webpack 打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听
webpack 打包过程中的某些节点，执行广泛的任务。

## vue 封装通用组件

通用组件必须具备高性能、低耦合的特性

**1、数据从父组件传入**

- a.为了解耦，子组件本身就不能生成数据。即使生成了，也只能在组件内部运作，不能传递出去。
- b.但是通用组件的的应用场景比较复杂，对 props 传递的参数应该添加一些验证规则
- c.props 中数据不要更改。

**2.在父组件处理事件**

- a.在通用组件中，通常会需要有各种事件， 比如复选框的 change 事件，或者组件中某个按钮的 click 事件
  这些事件的处理方法应当尽量放到父组件中，通用组件本身只作为一个中转,
  这样既降低了耦合性，也保证了通用组件中的数据不被污染
- b. 不过，并不是所有的事件都放到父组件处理 比如组件内部的一些交互行为，或者处理的数据只在组件内部传递，这时候就不需要用 $
  emit 了

**3. 合理使用 slot**
一般在不同场景显示不同组件。

**4.尽量不要依赖 vuex**

Vue 没有直接子对子传参的方法，建议将需要传递数据的子组件，都合并为一个组件。如果一定需要子对子传参，可以先从传到父组件，再传到子组件。
或者使用 pubSub.js 实现子组件之间互相传参数。

**5.动态组件**
Vue 还可以将多个子组件，都挂载在同一个位置，通过变量来切换组件，实现 tab 菜单这样的效果

```js
<component v-bind:is='tabView'></component>
```

**6.递归组件**
当组件拥有 name 属性的时候，就可以在它的模板内递归的调用自己，这在开发树形组件的时候十分有效

## vue 数据双向绑定原理

双向绑定是指数据模型（Module）和 视图（View）之间的双向绑定。 其原理是采用数据劫持结合发布订阅者模式实现。

- 1). 创建 vue 实例的过程中， 会先遍历 data 选项中所有的属性（发布者）， 用 Object.defineProperty 劫持这些属性将其转换为
  getter/setter。读取数据时候会触发 getter， 修改数据会触发 setter。

  代码：

    - 1).initData 初始化用户传入的数据
    - 2). new Observer 将数据进行观测。
    - 3). this.walk 进行对象的处理。
    - 4). defineReactive 循环对象属性定义响应式变化。
    - 5). Object.defineProperty 使用 Object.defineProperty 重新定义数据。 拦截属性的获取--进行依赖收集。 拦截属性的更新操作，
      对相关依赖进行通知。

- 2). 然后给每个对象属性对应的 new Dep(), Dep 专门收集依赖、删除依赖、向依赖发送消息。 dep 实际就是一个普通对象， 里边只有两个属性
  id,subs。 subs 存放 watcher 数组。
  先把每个依赖设置在 Dep.target 上。 在 Dep 中创建一个依赖数组， 先判断 Dep.target 是否已经在依赖数组中存在，
  如果不存在就添加到依赖数组中完成依赖收集。 随后 Dep.target 置为 null。
- 3). 组件在挂载过程中都会 new 一个 Watcher 实例。 这个实例就是依赖（订阅者）。 Watcher 的第二个参数是一个函数，
  此函数的作用是更新渲染节点。 在首次渲染过程， 会自动调用 Dep 方法收集依赖，
  收集完成后组件中每个数据都绑定上依赖。 当数据变化时就会在 setter 中调用 dep.notify 通知对应的依赖进行更新。 在更新过程中要读取数据，
  就会触发 Watcher 的第二个函数参数。 一触发就再次自动调用 Dep 方法收集依赖，
  同时在此函数中运行 patch（diff 运算）来更新对应的 DOM 节点， 完成了数据的双向绑定。

## mixin 合并规则

### 选项合并规则

1.数据对象（data）在内部会进行递归合并，并在发生冲突时以组件数据优先

2.同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用

3.值为对象的选项，例如 methods、components、watch 和
directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。Vue.extend() 也使用同样的策略进行合并

## elementUI 按需加载原理

。。。

## 图片懒加载原理

图片懒加载考虑哪些问题，实现的大概逻辑

## 统计页面停留时长

统计用户访问时长，如何优雅地发送统计数据到服务端（提示： 提出在路由钩子实现， 提到节流和防抖， 回答节流和防抖的原理）

## keep alive 原理

[keep alive 原理](https://cloud.tencent.com/developer/article/1605603)
[ keep alive 原理](https://github.com/answershuto/learnVue/blob/master/docs/%E8%81%8A%E8%81%8Akeep-alive%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.MarkDown)

## vue template 模板到解析层真实 DOM 的过程

## v-model 手动实现

[v-model 手动实现](https://segmentfault.com/a/1190000012264050)

## $nextTick 原理

[nextTick 原理 黄奕](https://ustbhuangyi.github.io/vue-analysis/v2/reactive/next-tick.html#js-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6)

[nextTick 原理 华为云](https://bbs.huaweicloud.com/blogs/235688)

## vuex 原理

[vuex 原理](https://segmentfault.com/a/1190000018251844)

## vue router 原理

[Vue Router](https://juejin.cn/post/6844903612930326541)

## v-if 和 v-show 区别

::: tip 相同点 两者都是在判断 DOM 节点是否要显示。
:::

::: tip
不同点
1、实现方式

v-if 是根据后面数据的真假值判断直接从 Dom 树上删除或重建元素节点

v-show 只是在修改元素的 css 样式，也就是 display 的属性值，元素始终在 Dom 树上。

2、编译过程

v-if 切换有一个局部编译/卸载的过程，切换过程中会销毁和重建内部的事件监听和子组件

v-show 只是简单的基于 css 切换

3、编译条件

v-if 是惰性的，如果初始条件为假，则什么也不做只有在条件第一次变为真时才开始局部编译

v-show 是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且 DOM 元素始终被保留

4、性能消耗

v-if 有更高的切换消耗，不适合做频繁的切换

v-show 有更高的初始渲染消耗，适合做频繁的额切换
:::

:::warning
v-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建
也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。

v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。 所以，v-if
适用于在运行时很少改变条件，不需要频繁切换条件的场景 v-show
则适用于需要非常频繁切换条件的场景
:::

## vue 开发插件流程

[vue 自定义插件](https://segmentfault.com/a/1190000010813937)

## computed 与 watch 区别

watch 和 computed 区别:

1.computed 是监听属性 依赖属性值发生变化的时候 数据才会变化. watch 是监听数据变化 执行相应的操作.
2.computed 有缓存 当依赖的属性没有发生变化的时候 则取缓存中的数据. watch 监听值是否发生变化, 都会调用回调函数.
3.computed 必须有 return watch 不需要
4.computed 不能有异步 watch 可以

::: tip 功能上：computed 是计算属性，也就是依赖其它的属性计算所得出最后的值。watch 是去监听一个值的变化，然后执行相对应的函数

使用上：computed 中的函数必须要用 return 返回 watch 的回调里面会传入监听属性的新旧值，通过这两个值可以做一些特定的操作，不是必须要用
return

性能上：computed 中的函数所依赖的属性没有发生变化，那么调用当前的函数的时候会从缓存中读取，而 watch 在每次监听的值发生变化的时候都会执行回调

场景上：computed：当一个属性受多个属性影响的时候，例子：购物车商品结算 watch：当一条数据影响多条数据的时候，例子：搜索框
:::

## vue router 相关问题待补充

## 分片下载与上传文件 如何实现

## vue diff 算法

## vue 模板编译过程

[vue 模板编译过程](https://segmentfault.com/a/1190000012922342)

## vue 组建 name 属性的作用

项目使用 keep-alive 时，可以搭配组件的 name 属性进行过滤
DOM 做递归组件时需要调用自身 name
vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的

## keep-alive 原理 loader：loader 是一个转换器，将 A 文件进行编译成 B 文件，属于单纯的文件转换过程；

plugin：plugin 是一个扩展器，它丰富了 webpack 本身，针对是 loader 结束后，webpack 打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听
webpack 打包过程中的某些节点，执行广泛的任务。
keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染
一般结合路由和动态组件一起使用，用于缓存组件
提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude
表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高
对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated

## vue 父子组建传递参数 8 种方式

> 参考地址： https://juejin.cn/post/6844904080540712967

## 组建化 和 MVVM

> 1.1 组件：把重复的代码提取出来合并成为一个个组件，组件最重要的就是重用（复用），位于框架最底层，其他功能都依赖于组件，可供不同功能使用，独立性强。

> 1.2
>
模块：分属同一功能/业务的代码进行隔离（分装）成独立的模块，可以独立运行，以页面、功能或其他不同粒度划分程度不同的模块，位于业务框架层，模块间通过接口调用，目的是降低模块间的耦合，由之前的主应用与模块耦合，变为主应用与接口耦合，接口与模块耦合。

### eg:

> 2.1 组件：就像一个个小的单位，多个组件可以组合成组件库，方便调用和复用，组件间也可以嵌套，小组件组合成大组件。
> 2.2 模块：就像是独立的功能和项目（如淘宝：注册、登录、购物、直播...），可以调用组件来组成模块，多个模块可以组合成业务框架。

## 响应式原理

## vdom 和 diff

## 模板编译

## 组建渲染过程

## 前端路由

## Object.defineProperty 和 Proxy 对比的缺点

:::tips 01.深度监听需要递归 02.无法监听新增属性与删除属性(Vue.$set Vue.$delete) 03.无法原生监听数组 需要特殊处理
:::

> Proxy 基本应用

:::tips

:::

> Reflect
